### 订单业务部分冲突
#### 订单状态之间的相互依赖和冲突 - 占着茅坑不拉屎
    - 最近接受了公司的订单 自动生成,和自动取消的业务,
    - 主要实现就是监控 自动生成 和 自动取消的队列, 取出数据,开始执行.
    - 这里订单的状态分别由 0 ,1 ,5 ,10 ... 依照业务顺序进行增加和变化
    - 自动生成控制了 0-1 的流程, 然后取消则可以 从 1,5,10 中取数据,本来这里不存在锁的问题,
    - 直到引入了自动审核,这是一个从1-20的正常流程, 这里很可能与 自动取消发生冲突
    - 那么很自然的, 经过讨论决定在程序中加上 redis 分布式锁,用来解决冲突.
    - 第一版的解决方案是这样的, 队列被触发的时候,就先把数据给锁上,如果推送失败就再次把消息推送到队列,解锁, 等待下一次被处罚.
	- 但是这里有个问题,由于三个队列相互之间没有触发的先后关系,但是取消队列的数据,却依赖于 自动生成队列. 所以当一个订单 状态是0 却被触发取消的时候就会出现 锁住,requeue,解锁,锁住 的循环, 然后其他的队列也获取不到锁. 就会产生死锁
	- 这其实是一个很容易解决的问题, 在现实生活中,这就叫做占着茅坑不拉屎, 首先取消队列应该先看一下 这条数据 自己到底能不能做, 不能做就requeue 等着 等到能做了之后 才能进行锁. 不然别人还上不上厕所了.
